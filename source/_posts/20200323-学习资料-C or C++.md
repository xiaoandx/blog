---
title: 学习 C/C++ 资料（基础知识四）
date: 2020-03-23 11:43:35
tags: [C or C++]
category: 学习资料
---

> 今天学习C语言中的数组，枚举

# C 语言中的数组

C 语言支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

![C 中的数组](https://www.runoob.com/wp-content/uploads/2014/08/arrays.jpg)

## 声明数组

在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：

```
type arrayName [ arraySize ];
```

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：

```
double balance[10];
```

现在 *balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。

## 初始化数组

在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

```
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

```
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：

```
balance[4] = 50.0;
```

上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：

![数组表示](https://www.runoob.com/wp-content/uploads/2014/08/array_presentation.jpg)

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```
double salary = balance[9];
```

上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：

### 实例

```c
#include <stdio.h>
 
int main ()
{
   int n[ 10 ]; /* n 是一个包含 10 个整数的数组 */
   int i,j;
 
   /* 初始化数组元素 */         
   for ( i = 0; i < 10; i++ )
   {
      n[ i ] = i + 100; /* 设置元素 i 为 i + 100 */
   }
   
   /* 输出数组中每个元素的值 */
   for (j = 0; j < 10; j++ )
   {
      printf("Element[%d] = %d\n", j, n[j] );
   }
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
```

## C 中数组详解

在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念：

| 概念           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| 多维数组       | C 支持多维数组。多维数组最简单的形式是二维数组。             |
| 传递数组给函数 | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |
| 从函数返回数组 | C 允许从函数返回数组。                                       |
| 指向数组的指针 | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |



### C 多维数组

C 语言支持多维数组。多维数组声明的一般形式如下：

```
type name[size1][size2]...[sizeN];
```

例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：

```
int threedim[5][10][4];
```

#### 二维数组

多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：

```c
type arrayName [ x ][ y ];
```

其中，**type** 可以是任意有效的 C 数据类型，**arrayName** 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：

```c
int x[3][4];
```

![C 中的二维数组](https://www.runoob.com/wp-content/uploads/2014/09/two_dimensional_arrays.jpg)

#### 初始化二维数组

多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。

```c
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

内部嵌套的括号是可选的，下面的初始化与上面是等同的：

```c
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

#### 访问二维数组元素

二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：

```
int val = a[2][3];
```

上面的语句将获取数组中第 3 行第 4 个元素。您可以通过上面的示意图来进行验证。让我们来看看下面的程序，我们将使用嵌套循环来处理二维数组：

##### 实例

```c
#include <stdio.h>
 
int main ()
{
   /* 一个带有 5 行 2 列的数组 */
   int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
   int i, j;
 
   /* 输出数组中每个元素的值 */
   for ( i = 0; i < 5; i++ )
   {
      for ( j = 0; j < 2; j++ )
      {
         printf("a[%d][%d] = %d\n", i,j, a[i][j] );
      }
   }
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
a[0][0] = 0
a[0][1] = 0
a[1][0] = 1
a[1][1] = 2
a[2][0] = 2
a[2][1] = 4
a[3][0] = 3
a[3][1] = 6
a[4][0] = 4
a[4][1] = 8
```

如上所述，您可以创建任意维度的数组，但是一般情况下，我们创建的数组是一维数组和二维数组。

#### 补充说明

二维数组在逻辑上是方阵，由行和列组成。

**但是二维数组在物理上是线性的，按行来依次进行存放，内存是连续的。**

二维数组名的步长是一行的长度，比如一下例子中：

```c
age + 1 address is 00EFFC04
age + 2 address is 00EFFC14
```

因为每一行有四个元素，每个int类型的元素占四个字节，一行有16个字节，所以数组名age加1后地址增加了16个字节说明数组名的步长位一行的长度。

具体到每一个元素加1的时候，地址增加的是一个元素所占字节的大小，因此元素的步长即为元素本身的大小，例如：

```c
age[2][0] + 0 address is 00EFFC14
age[2][0] + 1 address is 00EFFC18
```

示例及运行结果：

```c
#include <stdio.h>

int main()
{
    int age[6][4];
    for (int i = 0; i < sizeof(age)/sizeof(age[0]) ; i++)
    {
        printf("age + %d address is %p\n",i, age + i);
    }
    for (int i = 0; i < sizeof(age) / sizeof(age[0]); i++)
    {
        for (int j = 0; j < sizeof(age[0]) / sizeof(int); j++)
        {
            printf("age[%d][0] + %d address is %p\n",i,j,&age[i][0]+j);
        }

    }
}
```

输出结果：

```c
age + 0 address is 0x7fffd98b9400
age + 1 address is 0x7fffd98b9410
age + 2 address is 0x7fffd98b9420
age + 3 address is 0x7fffd98b9430
age + 4 address is 0x7fffd98b9440
age + 5 address is 0x7fffd98b9450
age[0][0] + 0 address is 0x7fffd98b9400
age[0][0] + 1 address is 0x7fffd98b9404
age[0][0] + 2 address is 0x7fffd98b9408
age[0][0] + 3 address is 0x7fffd98b940c
age[1][0] + 0 address is 0x7fffd98b9410
age[1][0] + 1 address is 0x7fffd98b9414
age[1][0] + 2 address is 0x7fffd98b9418
age[1][0] + 3 address is 0x7fffd98b941c
age[2][0] + 0 address is 0x7fffd98b9420
age[2][0] + 1 address is 0x7fffd98b9424
age[2][0] + 2 address is 0x7fffd98b9428
age[2][0] + 3 address is 0x7fffd98b942c
age[3][0] + 0 address is 0x7fffd98b9430
age[3][0] + 1 address is 0x7fffd98b9434
age[3][0] + 2 address is 0x7fffd98b9438
age[3][0] + 3 address is 0x7fffd98b943c
age[4][0] + 0 address is 0x7fffd98b9440
age[4][0] + 1 address is 0x7fffd98b9444
age[4][0] + 2 address is 0x7fffd98b9448
age[4][0] + 3 address is 0x7fffd98b944c
age[5][0] + 0 address is 0x7fffd98b9450
age[5][0] + 1 address is 0x7fffd98b9454
age[5][0] + 2 address is 0x7fffd98b9458
age[5][0] + 3 address is 0x7fffd98b945c
```

可以看到每一个元素占了四个字节的大小，并且这24的元素的地址是连续的。



### C 传递数组给函数

如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，您也可以传递一个多维数组作为形式参数。

#### 方式 1

形式参数是一个指针：

void myFunction(int *param) { . . . }

#### 方式 2

形式参数是一个已定义大小的数组：

void myFunction(int param[10]) { . . . }

#### 方式 3

形式参数是一个未定义大小的数组：

void myFunction(int param[]) { . . . }



现在，让我们来看下面这个函数，它把数组作为参数，同时还传递了另一个参数，根据所传的参数，会返回数组中各元素的平均值：

```c
double getAverage(int arr[], int size)
{
  int    i;
  double avg;
  double sum;
 
  for (i = 0; i < size; ++i)
  {
    sum += arr[i];
  }
 
  avg = sum / size;
 
  return avg;
}
```

现在，让我们调用上面的函数，如下所示：

```c
#include <stdio.h>
 
/* 函数声明 */
double getAverage(int arr[], int size);
 
int main ()
{
   /* 带有 5 个元素的整型数组 */
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;
 
   /* 传递一个指向数组的指针作为参数 */
   avg = getAverage( balance, 5 ) ;
 
   /* 输出返回值 */
   printf( "平均值是： %f ", avg );
    
   return 0;
}
 
double getAverage(int arr[], int size)
{
  int    i;
  double avg;
  double sum=0;
 
  for (i = 0; i < size; ++i)
  {
    sum += arr[i];
  }
 
  avg = sum / size;
 
  return avg;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
平均值是： 214.400000
```

您可以看到，就函数而言，数组的长度是无关紧要的，因为 C 不会对形式参数执行边界检查。

#### 补充注意

**二维数组传递给函数**

如果我们想将二维数组作为实参传递给某个函数，如下代码是有问题的:

```c
double * MatrixMultiple(double a[][], double b[][]);
```

原因可以简单理解为：编译器并没有那么高级，在二维以上的数组一定要规定一个最高维数:

```c
double * MatrixMultiple(double a[][2], double b[][3]);  /* 这才是正确的 */
```



### C 从函数返回数组

C 语言不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。我们将在下一章中讲解有关指针的知识，您可以先跳过本章，等了解了 C 指针的概念之后，再来学习本章的内容。

如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：

```c
int * myFunction() { . . . }
```

另外，C 不支持在函数外返回局部变量的地址，除非定义局部变量为 **static** 变量。

现在，让我们来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下：

#### 实例

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
/* 要生成和返回随机数的函数 */
int * getRandom( )
{
  static int  r[10];
  int i;
 
  /* 设置种子 */
  srand( (unsigned)time( NULL ) );
  for ( i = 0; i < 10; ++i)
  {
     r[i] = rand();
     printf( "r[%d] = %d\n", i, r[i]);
 
  }
 
  return r;
}
 
/* 要调用上面定义函数的主函数 */
int main ()
{
   /* 一个指向整数的指针 */
   int *p;
   int i;
 
   p = getRandom();
   for ( i = 0; i < 10; i++ )
   {
       printf( "*(p + %d) : %d\n", i, *(p + i));
   }
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
r[0] = 313959809
r[1] = 1759055877
r[2] = 1113101911
r[3] = 2133832223
r[4] = 2073354073
r[5] = 167288147
r[6] = 1827471542
r[7] = 834791014
r[8] = 1901409888
r[9] = 1990469526
*(p + 0) : 313959809
*(p + 1) : 1759055877
*(p + 2) : 1113101911
*(p + 3) : 2133832223
*(p + 4) : 2073354073
*(p + 5) : 167288147
*(p + 6) : 1827471542
*(p + 7) : 834791014
*(p + 8) : 1901409888
*(p + 9) : 1990469526
```



#### 补充说明

srand((unsigned)time(NULL))是初始化随机函数种子：

-  1、是拿当前系统时间作为种子，由于时间是变化的，种子变化，可以产生不相同的随机数。计算机中的随机数实际上都不是真正的随机数，如果两次给的种子一样，是会生成同样的随机序列的。 所以，一般都会以当前的时间作为种子来生成随机数，这样更加的随机。
-  2、使用时，参数可以是unsigned型的任意数据，比如srand（10）；
-  3、如果不使用srand，用rand（）产生的随机数，在多次运行，结果是一样的。

参考如下：

```c
void test_rand(void)
{
    unsigned long n;
    srand((unsigned)time(NULL));
    for(int i = 0; i < 100; i++)
    {
        n = rand();
        printf("d\n", n);
    }
}
```



### C 指向数组的指针

如果您对 C 语言中指针的概念有所了解，那么就可以开始本章的学习。数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：

```
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```
double *p;
double balance[10];

p = balance;
```

使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 *p、*(p+1)、*(p+2) 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：

#### 实例

```c
#include <stdio.h>
 
int main ()
{
   /* 带有 5 个元素的整型数组 */
   double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
   double *p;
   int i;
 
   p = balance;
 
   /* 输出数组中每个元素的值 */
   printf( "使用指针的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(p + %d) : %f\n",  i, *(p + i) );
   }
 
   printf( "使用 balance 作为地址的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(balance + %d) : %f\n",  i, *(balance + i) );
   }
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
使用指针的数组值
*(p + 0) : 1000.000000
*(p + 1) : 2.000000
*(p + 2) : 3.400000
*(p + 3) : 17.000000
*(p + 4) : 50.000000
使用 balance 作为地址的数组值
*(balance + 0) : 1000.000000
*(balance + 1) : 2.000000
*(balance + 2) : 3.400000
*(balance + 3) : 17.000000
*(balance + 4) : 50.000000
```

在上面的实例中，p 是一个指向 double 型的指针，这意味着它可以存储一个 double 类型的变量。一旦我们有了 p 中的地址，***p** 将给出存储在 p 中相应地址的值，正如上面实例中所演示的。



#### 小知识点补充

1. **一个小知识点：**

   在我们没有明确数组的元素个数时，在程序中想知道数组单元个数可以使用 **sizeof(a)/sizeof(a[0])**, **sizeof(a)** 是得到数组 a 的大小，**sizeof(a[0])** 是得到数组 a 中单个元素的大小（因此可以不必要是a[0],a[i]都行），eg:

   ```c
   #include<stdio.h>
   
   int main(int argc,char *grgv[])
   {
       int a[]={1,2,3,4,5};
       int b;
       b=sizeof(a)/sizeof(a[0]);
       printf("数组元素个数为：%d",b);
       return 0; 
   }
   ```

   

   数组是一种一次申请多个变量的方法，数组的使用让我们可以在程序中保留多个变量的值，进行处理，例如给定n个学生的成绩，要求有多少学生超过了平均分,代码如下：

   ```c
   #include <stdio.h>  //导如输入输出头文件
   
   int main(){
       //主函数 
       int cj[100]={0};//定义数组 
       int n;
       int count=0;//定义计数器，统计有多少人达到平均分 
       scanf("%d",&n);
       int i=0;
       //读入数据 
       for(i=0;i<n;i++){
           scanf("%d",&cj[i]);
       } 
       //对数据进行求和 
       double sum=0;
       for(i=0;i<n;i++){
           sum+=cj[i];
       } 
       //求平均分 
       double arg=sum/n;
       //判断有多少人达到平均分； 
       for(i=0;i<n;i++){
           if(cj[i]>arg){
               count++;
           }
       } 
       //输出平均分和人数 
       printf("平均分为：%0.2f\n超过平均分的人有：%d个\n",arg,count);
     return 0;
   }
   ```

   

   ```c
   #include <stdio.h>
   
   int main()
   {
       int a[2] = {1,2};
       printf("a      = %d\n",a[0]);
       printf("*(a+0) = %d\n",*(a + 0));
       printf("a[1]   = %d\n",a[1]);
       printf("*a     = %d\n",*a);
       printf("*(a+1) = %d\n",*(a + 1));
       printf("\n");
       printf("a    的地址：%p\n",a);
       printf("(a+0)的地址：%p\n",(a + 0));
       printf("(a+1)的地址：%p\n",(a + 1));
       // %p 读入一个指针
       printf("\n");
       return 0;
   }
   ```

   输出结果：

   ```c
   a      = 1
   *(a+0) = 1
   a[1]   = 2
   *a     = 1
   *(a+1) = 2
   
   a    的地址：0x7ffe9e227634
   (a+0)的地址：0x7ffe9e227634
   (a+1)的地址：0x7ffe9e227638
   ```

   事实上 **a[0] 、a[1]...a[i]** 代表的都是值，**a、(a+0)、(a+1)、(a+i)** 代表的是地址；另外这里的 **a** 代表整个数组的首地址，相当于 **a[0]** 的地址，而这里 **(a+1)** 就代表的是 **a[0+1]** 的地址。

   正如文章中提到的：所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素，即是说 **(a+i)** 就代表的是 **a[0+i]** 的地址。

   

   对于数组的初始化需要注意以下几点：

   1) 可以只给部分元素赋值，当 **{ }** 中值的个数少于元素个数时，只给前面部分元素赋值。例如：

   ```c
   int a[10]={12, 19, 22 , 993, 344};
   ```

   表示只给 **a[0]~a[4] 5** 个元素赋值，而后面 **5** 个元素自动初始化为 **0**。

   当赋值的元素少于数组总体元素的时候，不同类型剩余的元素自动初始化值说明如下：

   -  对于 short、int、long，就是整数 **0**；
   -  对于 char，就是字符 **'\0'**；
   -  对于 float、double，就是小数 **0.0**。

   我们可以通过下面的形式将数组的所有元素初始化为 0：

   ```c
   int nums[10] = {0};
   char str[10] = {0};
   float scores[10] = {0.0};
   ```

   由于剩余的元素会自动初始化为 0，所以只需要给第 0 个元素赋值为 0 即可。

   2) 只能给元素逐个赋值，不能给数组整体赋值。例如给 10 个元素全部赋值为 1，只能写作：

   ```c
   int a[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   ```

   而不能写作：

   ```c
   int a[10] = 1;
   ```

   

   ##### **指针与数组名的区别**

   指针：也是一个变量，存储的数据是地址。

   数组名：代表的是该数组最开始的一个元素的地址。

   ```c
   int a[10];
   int *p;
   p = &a[0] // 可以写成 p = a;
   ```

   - 对数组元素 a[i]的引用也可以写成*(a+i)这种形式。
   - 赋值语句  p=&a[0] 也可以写成下列形式: p=a。
   - p 是个指针，p[i]与*(p+i)是等价的。

   区别：指针是一个变量，可以进行数值运算。数组名不是变量，不可以进行数值运算。

   

   ##### **数组和指针的关系**

   1. 函数的参数中 数组类型参数 `int a[]`本质是指针 可以直接换成 `int *a`;
   2. 可以用数组的运算符`[]`进行运算，而且可以通过`a[0]`就直接修改了外面的数组元素;
   3. `size of(a) == sizeof(int *)` 所以函数内部没法用`sizeof`得到数组的长度 只能传一个`len`;

   ```c
   // 一个整型数组的指针，长度为 len， 得到数组中的最小值和最大值 ———— 从外部传入两个指针，从而将所求的两个结果保存带出来，得到多个返回值。
   void minMax(int a[], int len, int *min, int *max) {
       int i;
       
       *min = *max = a[0]; //假定最大值 最小值相等 为a[0]  
       
       for(i= 1; i < len, i++) {
           if( a[i] < *min) {
             *min = a[i];
           }
           
           if(a[i] > *max) {
             *max = a[i];
           }
       }
   
   }
   
   int a[] = {1, 2, 3, 4, 5, 7, 8, 9, 15, 18, 25, 33};
   int min, max;
   minMax(a, sizeof(a)/ sizeof(a[0]), &min , &max );
   printf( "min = %d, max = %d \n",  min,  max);
   ```

   - 数组变量是特殊的指针，数组变量本身表达地址，int a[10];   int *p =a;
   - 数组变量无需用取址符& ;
   - 数组的元素表达的是变量，需要用&取地址,如 m = &a[0];
   - `[]`运算符可以对数组做，也可以对指针做 `p[0] == a[0]`;
   - `*`运算符可以对指针做，也可以对数组做 `*a = 25`, *a可以得到或者修改数组首个元素的值;
   - 实际上数组是 const 的指针，所以不能被赋值。 如果 `int a[] = {1,2,5,7}`; `int b[]`，由于 `int b[]`实质上等价于 <===> int const *b;    b 是一个常数，不能被改变，初始化出来代表这个数组就不能再改变。 b = a; (错误) 数组变量之间是不可以这样互相赋值的。 而 int *q = a; 这样是可以的。

   

   ##### **数组赋值的区别:**

   ```c
   char a[]="runoob"; // 这样赋值之后在结尾会自动加上'\0'。
   char a1[]={'r','u','n','o','o','b'}; // 这样赋值是整整好好的6个空间不会自动加上 <span class="marked">\0</span>。
   ```

   所以比较的话，a 的长度比 a1 的要大。

   

   数组初始化技巧: 将元素全部置零 **{0}**。

   ```c
   #include <stdio.h>
   
   int main()
   {
       double arr[10] = {0};
   
       for(int i=0; i<sizeof(arr)/sizeof(double); i++)
           printf("%d ", arr[i]);
       printf("\n\n");
   
       int a[3][4] = {0};
       for(int i=0; i<3; i++)
           {
           for(int j=0; j<4; j++)
                   printf("%d ", a[i][j]);
           printf("\n");
           }
       
       return 0;
   }
   ```

   

   可将枚举、数组和结构体结合起来使用，例如输入5个人的姓名、学号、成绩，但是光靠记忆是记不住哪个人的成绩是数组中第几个元素：

   ```c
   struct Student 
   {
       char name;
       long num;
       double grade;
   } ST;
   
   struct Student ST = {{"zhangsan", 0001, 86},
         {"lisi", 0002, 72.5}, 
         {"wangwu", 0003, 60}, 
         {"chenliu", 0004, 23}, 
         {"cuihua", 0005, 92}};
   enum ST_INDEX
   {
       zhangsan  = 0,
       lisi,
       wangwu,
       chenliu,
       cuihua,
   }
   ```

   这样通过索引枚举中各个人的名字作为数组中的元素位置即可快速查询某个人的成绩等信息。

   

   int a[10];

   数组名是指向数组首个元素的指针常量，*a==a[0]，*(a+1)==a[1]，其类型应该为指向int类型的指针：

   int *；

   对数组名取地址：&a，得到的应该是整个数组的地址。这时可以认为a是整个数组的变量名，对变量名进行取地址操作：&，会得到该变量的地址；

   操作：（&a+1）得到的是增大整个数组内存大小的地址：增大4*10。



# C enum(枚举)

枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。

枚举语法定义格式为：

```c
enum　枚举名　{枚举元素1,枚举元素2,……};
```

接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：

```c
#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
```

这个看起来代码量就比较多，接下来我们看看使用枚举的方式：

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

这样看起来是不是更简洁了。

**注意：**第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。

> 可以在定义枚举类型时改变枚举元素的值：
>
> ```
> enum season {spring, summer=3, autumn, winter};
> ```
>
> 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5

### 枚举变量的定义

前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。

我们可以通过以下三种方式来定义枚举变量

**1、先定义枚举类型，再定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```

**2、定义枚举类型的同时定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**3、省略枚举名称，直接定义枚举变量**

```
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

#### 实例

```c
#include<stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
 
int main()
{
    enum DAY day;
    day = WED;
    printf("%d",day);
    return 0;
}
```

以上实例输出结果为：

```
3
```

在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。

不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。

以下实例使用 for 来遍历枚举的元素：

```c
#include<stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
int main()
{
    // 遍历枚举元素
    for (day = MON; day <= SUN; day++) {
        printf("枚举元素：%d \n", day);
    }
}
```

以上实例输出结果为：

```
枚举元素：1 
枚举元素：2 
枚举元素：3 
枚举元素：4 
枚举元素：5 
枚举元素：6 
枚举元素：7
```

以下枚举类型不连续，这种枚举无法遍历。

```c
enum
{
    ENUM_0,
    ENUM_10 = 10,
    ENUM_11
};
```

枚举在 switch 中的使用：

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
 
    enum color { red=1, green, blue };
 
    enum  color favorite_color;
 
    /* ask user to choose color */
    printf("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): ");
    scanf("%d", &favorite_color);
 
    /* 输出结果 */
    switch (favorite_color)
    {
    case red:
        printf("你喜欢的颜色是红色");
        break;
    case green:
        printf("你喜欢的颜色是绿色");
        break;
    case blue:
        printf("你喜欢的颜色是蓝色");
        break;
    default:
        printf("你没有选择你喜欢的颜色");
    }
 
    return 0;
}
```

以上实例输出结果为：

```
请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1
你喜欢的颜色是红色
```

### 将整数转换为枚举

以下实例将整数转换为枚举：

```c
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
 
    enum day
    {
        saturday,
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday
    } workday;
 
    int a = 1;
    enum day weekend;
    weekend = ( enum day ) a;  //类型转换
    //weekend = a; //错误
    printf("weekend:%d",weekend);
    return 0;
}
```

以上实例输出结果为：

```
weekend:1
```



### 补充说明

1. 用 for 用来遍历枚举元素根本是不可行的，直接上代码：

   ```c
   #include<stdio.h>
   enum DAY{MON=1, TUE, WED, THU=7, FRI, SAT, SUN};
   
   int main()
   {
           enum DAY day;
           for(day=MON;day<=SUN;day++)
           {
                   printf("day=%d\n",day);
           }
           return 0;
   }
   ```

   得到的结果：

   ```c
   day=1
   day=2
   day=3
   day=4
   day=5
   day=6
   day=7
   day=8
   day=9
   day=10
   ```

   所以用来遍历是不可行的，它只是给 day 赋值了一个整数类型的值。

   

   枚举其实可以直接使用，上代码：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   enum {
    Q,W,E=4,R
   };
   
   int main()
   {
   
      printf("枚举值QWER分别是: %d , %d , %d , %d",Q,W,E,R);
      
      return 0;
   }
   ```

   输出:

   ```
   枚举值QWER分别是: 0 , 1 , 4 , 5
   ```

   

   ```c
   #include<stdio.h>
   enum DAY{MON=1, TUE, WED, THU=7, FRI, SAT, SUN};
   
   int main()
   {
           enum DAY day;
           for(day=MON;day<=SUN;day++)
           {
                   printf("day=%d\n",day);
           }
           return 0;
   }
   ```

   ```c
   #include<stdio.h>
   enum DAY{MON=1, TUE=2, WED=3, THU=7, FRI=8, SAT=9, SUN=10};
   
   int main()
   {
           enum DAY day;
           for(day=MON;day<=SUN;day++)
           {
                   printf("day=%d\n",day);
           }
           return 0;
   }
   ```

   ```c
   #include<stdio.h>
   enum DAY{MON=1, TUE, WED, THU=7, FRI, SAT, SUN};
   
   int main()
   {
           enum DAY day;
           for(day=1;day<=10;day++)
           {
                   printf("day=%d\n",day);
           }
           return 0;
   }
   ```

   这 3 个是等价的，不明白你们说的遍历是否可行是什么意思但是。

   ```c
   enum
   {
       ENUM_0,
       ENUM_10 = 10,
       ENUM_11
   };
   ```

   

   **关于遍历问题的讨论：**

   首先大家要清楚在 c 语言中枚举元素的数据类型是被当成了 int 或者 unsigned int 型，不会是其他数据类型，如浮点型。简单而言，每个枚举元素可以看作为一个整形变量的宏定义。所以无论是哪种形式的遍历，大家都可以看成是对整形变量的操作。至于作者说的条件的遍历情况无非是恰好满足了遍历时 枚举变量的值 恰好是和定义好的枚举类型中的值一样罢了。可能说得有点抽象，一个栗子帮助大家理解：

   一、

   ```c
   #include <stdio.h>
   
   int main(void)
   {
       enum MONTH{A=1,B,C,D,F=10};    //注意B的值是在A加1，C是B加1....所以D你知道吧
       enum MONTH month=A;
       for(month=A;month<F;month++)
       printf("the value of month is :%d  ",month);
       return 0;
   }
   ```

   二、

   ```c
   #include <stdio.h>
   
   int main(void)
   {
       int month=1;
       int F=10;
       for(month=1;month<F;month++)
       printf("the value of month is :%d  ",month);
       return 0;
   }
   ```

   

   枚举类型连续，遍历时要加类型转换:

   ```c
   #include<stdio.h>
   
   enum DAY
   {
       MON=1, TUE, WED, THU, FRI, SAT, SUN
   } weekend;
   
   int main()
   {
       weekend=MON;
       printf("day is %d\n",weekend);
       // 遍历枚举元素
       while(weekend<=SUN)
       {
           printf("枚举元素：%d \n",weekend);  //类型扎UN哈UN
           weekend=(enum DAY)(weekend+1);
       }
   }
   ```

   

   关于枚举元素遍历问题的个人理解：

   首先有个前提：定义的枚举元素从第二个元素开始，每个元素的值是在前一个元素的值得基础上加 1。

   以下为一般情况，即 for 循环每次增加固定值(每次加 1 或者加 2.....)

   当你定义的元素是在 0 的基础上进行自增，那么采用 for 循环遍历时，则刚好能够正确遍历全部元素。因为此时 for 循环中用来自增判断的枚举变量的值能够与定义的元素值对应上，假设你定义了 7 个元素，并且第一个元素的值为 0，剩下 6 个元素没有另外再赋值或者按自增进行赋值，那么 day=0 时，输出的第一个枚举元素也是 0，day=6 时，输出为 6，刚好输出全部元素。

   ```c
   #include<stdio.h>
   
   enmu {
       MON=0,TUE,WED,THU,FRI,SAT,SUN
   } day;
   
   int main()
   {
       for(day=0;day<SUN,day++)
       {
           printf("枚举元素：%d \n",day)   //实际上输出的是day这个变量的值，并不是所定义的枚举元素 
       }
   }
   ```

   ```
   当你定义的元素不是连续自增时，假设你定义了 7 个元素，第一个元素为 0，第 3 个元素为 5，那么你采用 for 循环遍历，输出的值不等于你定义的 7 个元素的值。因为 for 循环每次是增加固定值(假设每次增加 1)，那么当 day=2 时，定义的第三个元素为 5，但是此时输出的是 day 这个变量的值 3，并不是所定义的第三个元素。
   ```

   ```c
   #include<stdio.h>
   
   enmu {
       MON=0,TUE,WED=5,THU,FRI,SAT,SUN
   } day;
   
   int main()
   {
       for(day=0;day<SUN,day++)
       {
           printf("枚举元素：%d \n",day)   //实际上输出的是day这个变量的值，并不是所定义的枚举元素 
       }
   }
   ```